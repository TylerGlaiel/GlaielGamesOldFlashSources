package  {	import flash.xml.*;	import flash.display.MovieClip;	import flash.utils.*;	public class Wave {		[Embed(source = "enemies.xml",mimeType = "application/octet-stream")]		private var EnemXML:Class;				public static var ROOT:MovieClip;				private var data:XML;		private var enemies:XML;		public var num:int;		private var timer:int;		public var name:String;		private var timeout:int;				private var groups:Vector.<Group>;				public function Wave(dat:XML) { 			timer = 0;			num = 0;			groups = new Vector.<Group>();			//trace(dat.toXMLString());			data = dat;			name = dat.attribute("name");			timeout = dat.attribute("timeout");			//trace(name);						enemies = new XML(new EnemXML());			//decode groups			var grouplist:XMLList = data.children();			var item:XML;            for each(item in grouplist) {                groups.push(new Group(item));            }		}				public function update(){			if(num >= groups.length){				timer++;				return;			}			if(groups[num].doneSP){				num++;				if(num >= groups.length) return;			}			var toSpawn:Spawn = groups[num].update();			if(toSpawn != null){				spawnThing(toSpawn);			}			if(groups[num].cycle){				var b:Boolean = true;				for(var i:int = 0; i<num; i++){					if(!groups[i].done) b = false;				}				if(b) groups[num].cycle = false;			}		}				public function get done():Boolean{			if(num != groups.length) return false;			if(timeout > 0 && timer > timeout) return true;			for(var i:int = 0; i<groups.length; i++){				if(!groups[i].done) return false;			}			return true;		}		//SPAWN FACTORY		///////////////		private function spawnThing(s:Spawn){			//trace("Spawning: "+s.name);			if(!s.powerup){								var type:XMLList = enemies.enemy.(@name==s.name);				var AI:Class = getDefinitionByName(type.child("class")) as Class;				var Graphic:Class = getDefinitionByName(type.child("graphic")) as Class;				var life:int = type.life=="auto" ? 100 : type.life;				var damage:int = type.damage=="auto" ? -1 : type.damage;				var radius:int = type.radius=="auto" ? 0 : type.radius;				var mass:int = type.mass=="auto" ? -1 : type.mass;				var points:int = type.points=="auto" ? life : type.points;								var t:Attractable = new Attractable(new Graphic(), life, damage, radius, mass, points);				ROOT.shipLayer.addChild(t.clip);				t.enm = new AI(t, ROOT.base);				ROOT.objects.push(t);								s.link = t;			} else {				var t:Attractable = new Attractable(new Powerup(), 1, 0);				if(s.name == "Health") t.damage = -50;				MovieClip(t.clip).gotoAndStop(s.name);								var pos:Vec2D = new Vec2D(200+Math.random()*100, 0);				pos.rotate(Math.random()*360);				t.x = 350+pos.x;				t.y = 300+pos.y;				t.clip.rotation = Math.random()*360;								ROOT.shipLayer.addChild(t.clip);				t.enm = new String(s.name);				ROOT.objects.push(t);				s.link = t;			}		}		}	}internal class Group {	public var cycle:Boolean;	public var frequency:int;	public var time:int;	public var cycles:int;	private var num:int;	private var timer:int;	private var spawns:Vector.<Spawn>;		public function Group(dat:XML) {		if(dat.localName() == "group" || dat.localName() == "cycle"){			frequency = dat.attribute("freq");			if(dat.localName() == "cycle"){				cycle = true;				time = dat.attribute("time");				cycles = dat.attribute("repeat");			}			spawns = new Vector.<Spawn>;			var elist:XMLList = dat.children();			var item:XML;            for each(item in elist) {				var count:int = item.count;				for(var i:int = 0; i<count; i++){					var t:Spawn = new Spawn();					if(item.localName() == "powerup"){						t.powerup = true;					}					t.name = item.type;					spawns.push(t);				}            }			shuffle();		} else {			cycle = false;			time = Number(dat.toString());			spawns = null;		}		timer = frequency;	}	public function update():Spawn {		timer++;		if(spawns == null) return null;		if(num >= spawns.length && cycle && timer > time && --cycles != 0){			num = 0;			timer = 0;		}		if(timer > frequency){			if(num >= spawns.length) return null;			timer = 0;			return spawns[num++];		}		return null;	}	public function get done():Boolean{		if(spawns == null) return timer > time;		if(num < spawns.length) return false;		for(var i:int = 0; i<spawns.length; i++){			if(!spawns[i].killed) return false;		}		return true;	}	public function get doneSP():Boolean{		if(spawns == null) return timer > time;		if(cycle) return false;		if(num < spawns.length) return false;		return true;	}		private function shuffle(){		var n:int = spawns.length;		while(n>1){			var k:int = Math.random()*n;			n--;						var tmp:Spawn = spawns[k];			spawns[k] = spawns[n];			spawns[n] = tmp;		}	}}internal class Spawn {	public var powerup:Boolean;	public var name:String;	public var link:Attractable;	public function Spawn() {		link = null;		powerup = false;	}	public function get killed():Boolean {		if(link == null || !link.alive){			link = null;			return true;		}		return false;	}}