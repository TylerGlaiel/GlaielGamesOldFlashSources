package {	import flash.display.Sprite;	import flash.events.Event;	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.geom.*;	public class Attractable {		static public var ROOT:MovieClip;		public var momentum:Vec2D;		public var clip:Sprite;		public var alive:Boolean;		public var invmass:Number;		public var radius:Number;		public var health:Number;		public var damage:int;		public var stable:Boolean;		public var points:int;				public var held:int		public var friction:Number;				public var stimer;		public var targetable:Boolean;		public var blocking:Boolean;				public var enm:Object;		public var targT:Attractable;		public var breakTether:int;		public var rumble:int;				private var LifeBar:MovieClip;		public var maxLife:Number;		private var plife:Number;		private var lifebar:Boolean;		private var ttimer:int;		private var lbt:int;				public var multiplier:int;				private var alias:Vec2D;		private var useAlias:Boolean;		/////		static private var redTransform:ColorTransform = new ColorTransform(1, 0, 0, 1, 255, 0, 0, 0);		static private var greenTransform:ColorTransform = new ColorTransform(0, 1, 0, 1, 0, 255, 0, 0);				static private var nullTransform:ColorTransform = new ColorTransform(1, 1, 1, 1, 0, 0, 0, 0);		public function Attractable(c:Sprite, l:int = 100, d:int = -1, r:Number = 0, m:Number = -1, p:int = 0, lb:Boolean = true){			rumble = 5;			points = p;			breakTether = 0;			health = l;			damage = d;			targetable = true;			blocking = false;			useAlias = false;			if(d == -1) damage = l;			if(r == 0) {				radius = c.width/2;			} else {				radius = r;			}			if(m<0){				invmass = 1.0/radius;			} else if(m>0){				invmass = 1.0/m;			} else {				invmass = 0;			}			clip = c;			alive = true;			stable = true;			stimer = 0;			momentum = new Vec2D(0, 0);						held = 0;			multiplier = 1;						enm = null;			targT = null;			friction = .95;						lifebar = lb;							plife = life;			if(lifebar){				LifeBar = new LIFEBAR();				ROOT.hudLayer.addChild(LifeBar);				LifeBar.visible = false;			}				maxLife = life;				lbt = 0;				ttimer = 0;		}		public function setAliasPos(x_:Number, y_:Number){			alias = new Vec2D(x_, y_);			useAlias = true;		}		public function update(){			if(!alive) return;			if(breakTether > 0){				breakTether--;			}			if(multiplier > 1){				multiplier--;			}			if(held > multiplier){				multiplier = held;			}			momentum.x *= friction;			momentum.y *= friction;			clip.x += momentum.x * invmass;			clip.y += momentum.y * invmass;			if(invmass != 0){				if(held == 0){					stimer -= 1;					if(stimer < 0){						stable = true;					}				} else {					stimer = 90;				}			}			if(health <= 0){				die();			}										if(plife > life){					MovieClip(clip).transform.colorTransform = redTransform;					ttimer = 3;					lbt = 30;				}				if(plife < life){					MovieClip(clip).transform.colorTransform = greenTransform;					ttimer = 3;					lbt = 30;				}								ttimer -= 1;				if(ttimer < 0){					MovieClip(clip).transform.colorTransform = nullTransform;				} else {					var ctf:ColorTransform = MovieClip(clip).transform.colorTransform;					MovieClip(clip).transform.colorTransform = new ColorTransform(.5*(ctf.redMultiplier+1),.5*(ctf.greenMultiplier+1),.5*(ctf.blueMultiplier+1),1,																						 .5*(ctf.redOffset+1),.5*(ctf.greenOffset+1),.5*(ctf.blueOffset+1),0);				}												plife = life;				if(plife > maxLife){					maxLife = plife;				}							if(lifebar){				LifeBar.bar.scaleX = plife/maxLife;				LifeBar.x = x;				LifeBar.y = y + radius;								if(lbt > 0){					if(lbt < 28){						LifeBar.visible = true;						LifeBar.alpha = lbt/10;					}					lbt--;				} else {					LifeBar.visible = false;				}			}		}		public function die(){			if(alive){				if(lifebar){					ROOT.hudLayer.removeChild(LifeBar);				}				lifebar = false;				clip.parent.removeChild(clip);				//clip = null;				alive = false;			}		}		public function breakTethers(){			breakTether = 2;		}		public function collided(a:Attractable){			return ((a.x-x)*(a.x-x) + (a.y-y)*(a.y-y) < (radius+a.radius)*(radius+a.radius));		}		public function pcollide(vx:Number, vy:Number){			return ((vx-x)*(vx-x) + (vy-y)*(vy-y) < (radius+30)*(radius+30));		}				public function get x(){if(useAlias) return alias.x; else return clip.x; }		public function set x(n:Number){ clip.x = n; }		public function get y(){if(useAlias) return alias.y; else return clip.y; }		public function set y(n:Number){ clip.y = n; }				public function get life() { return health; }		public function set life(l:Number) { 			health = l;		}		public function modDamage(tgt:Attractable){			if(enm != null && enm is Enemy){				Enemy(enm).modDamage(tgt);			}		}	}}