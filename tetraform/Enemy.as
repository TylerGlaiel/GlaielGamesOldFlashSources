package {	import flash.events.Event;	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.geom.*;	public class Enemy {		public static var BMP:BitmapData;		public static var ScaleDown:Number;		public static var ROOT:MovieClip;		protected var handle:Attractable;		protected var base:Attractable;		//private var plife:Number;		//private var ttimer:int;		//private var lbt:int;		//private var LifeBar:MovieClip;		private var Arrow:MovieClip;		//private var maxLife:Number;		public function Enemy (a:Attractable, b:Attractable, place:Boolean = true){						if(place){				if(Math.random()<.5){					a.x = (Math.random()-.5)*(Playfield.width+100)+(Playfield.x);					a.y = Math.random()<.5 ? (Playfield.ymin-50) : (Playfield.ymax+50);				} else {					a.y = (Math.random()-.5)*(Playfield.height+100)+(Playfield.y);					a.x = Math.random()<.5 ? (Playfield.xmin-50) : (Playfield.xmax+50);				}			}			handle = a;			base = b;			//handle.clip.addEventListener(Event.ENTER_FRAME, this.eupdate, false, 0, true);			ROOT.enemylist.push(this);			/*plife = handle.life;						LifeBar = new LIFEBAR();			ROOT.hudLayer.addChild(LifeBar);			LifeBar.visible = false;						maxLife = handle.life;*/						//lbt = 0;						Arrow = new Indicator();			ROOT.arrows.addChild(Arrow);			Arrow.alpha = 0;			Arrow.scaleX = Arrow.scaleY = handle.radius/100;		}				static private var redTransform:ColorTransform = new ColorTransform(1, 0, 0, 1, 255, 0, 0, 0);		static private var greenTransform:ColorTransform = new ColorTransform(0, 1, 0, 1, 0, 255, 0, 0);				static private var nullTransform:ColorTransform = new ColorTransform(1, 1, 1, 1, 0, 0, 0, 0);		public function eupdate(){						//arrow update			var dC:Vec2D = new Vec2D(handle.x*ROOT.game.scaleX+ROOT.game.x - 350, handle.y*ROOT.game.scaleY+ROOT.game.y - 300);						if(Math.abs(dC.x)<350 && Math.abs(dC.y)<300){				Arrow.visible = false;			} else {				Arrow.visible = true;							dC.norm();				Arrow.rotation = dC.rotation+90;								var distB:Number = (handle.x-base.x)*(handle.x-base.x)+(handle.y-base.y)*(handle.y-base.y);				Arrow.alpha = 1.0-Math.sqrt(distB/(1050*1050));								dC.scale(350/Math.abs(dC.x));				if(Math.abs(dC.y) > 300){					dC.scale(300/Math.abs(dC.y));				}								Arrow.x = 350+dC.x;				Arrow.y = 300+dC.y;								if(handle == ROOT.selobj){					Arrow.gotoAndStop(2);				} else {					Arrow.gotoAndStop(1);				}			}						var dist:Vec2D = new Vec2D(handle.x - 350, handle.y-300);			if(dist.length2 > 2000*2000*2){				handle.points = 0;				handle.life = 0;			}						//						/*if(plife > handle.life){				MovieClip(handle.clip).transform.colorTransform = redTransform;				ttimer = 3;				lbt = 30;			}			if(plife < handle.life){				MovieClip(handle.clip).transform.colorTransform = greenTransform;				ttimer = 3;				lbt = 30;			}						ttimer -= 1;			if(ttimer < 0){				MovieClip(handle.clip).transform.colorTransform = nullTransform;			} else {				var ctf:ColorTransform = MovieClip(handle.clip).transform.colorTransform;				MovieClip(handle.clip).transform.colorTransform = new ColorTransform(.5*(ctf.redMultiplier+1),.5*(ctf.greenMultiplier+1),.5*(ctf.blueMultiplier+1),1,																					 .5*(ctf.redOffset+1),.5*(ctf.greenOffset+1),.5*(ctf.blueOffset+1),0);			}									plife = handle.life;			if(plife > maxLife){				maxLife = plife;			}						LifeBar.bar.scaleX = plife/maxLife;			LifeBar.x = handle.x;			LifeBar.y = handle.y + handle.radius;						if(lbt > 0){				if(lbt < 28){					LifeBar.visible = true;					LifeBar.alpha = lbt/10;				}				lbt--;			} else {				LifeBar.visible = false;			}*/						if(ROOT.gamepaused) return;						if(handle == null || !handle.alive || handle.enm != this){				if(handle != null){					//handle.clip.removeEventListener(Event.ENTER_FRAME, this.eupdate);					handle = null;					cleanup();					//ROOT.hudLayer.removeChild(LifeBar);					ROOT.arrows.removeChild(Arrow);					return false;				}			} else {				update();				if(handle.clip.rotation == undefined || isNaN(handle.clip.rotation)){					handle.clip.rotation = 0;				}				return true;			}		}		public function update(){			var dist:Vec2D = new Vec2D(base.x - handle.x, base.y-handle.y);			dist.norm();			handle.momentum.x += dist.x*3;			handle.momentum.y += dist.y*3;			handle.clip.rotation = Vec2D.angle2(new Vec2D(0, -1), handle.momentum);		}		public function drawParticles(){		}		public function cleanup(){		}		public function modDamage(tgt:Attractable){		}	}}