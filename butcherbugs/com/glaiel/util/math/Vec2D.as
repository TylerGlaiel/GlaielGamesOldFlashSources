//COPYRIGHT TYLER GLAIEL 2008-2010//VERSION 3.42//LAST MODIFIED: 4/21/10package com.glaiel.util.math{	import flash.display.Sprite;	public class Vec2D {		public var x:Number;		public var y:Number;		public function Vec2D(i:Number, j:Number):void {			x = i;			y = j;		}		public function copy():Vec2D {			return new Vec2D(x, y);		}		public static function fromAngle(angle:Number):Vec2D {			var temp:Vec2D = new Vec2D(1, 0);			temp.rotate(angle);			return temp;		}		public function norm():void {			var l:Number = length;			if (l != 0) {				x /= l;				y /= l;			}		}		public function normalize():void {			norm();		}		public function normalized():Vec2D {			var temp:Vec2D = copy();			temp.norm();			return temp;		}		public function get rotation():Number {			return Math.atan2(y, x)*57.29577951308232;		}		public static function add(v:Vec2D, v2:Vec2D):Vec2D {			return new Vec2D(v2.x + v.x,v2.y + v.y);		}		public static function subtract(v:Vec2D, v2:Vec2D):Vec2D {			return new Vec2D(v.x - v2.x,v.y - v2.y);		}		public static function dot(v:Vec2D, v2:Vec2D):Number {			return v2.x * v.x + v2.y * v.y;		}		public static function cross(v:Vec2D, v2:Vec2D):Number {			return v.x*v2.y - v.y*v2.x;		}		public static function angle(v:Vec2D, v2:Vec2D):Number {			const ret:Number = Math.acos(dot(v,v2) / (v2.length * v.length)) * 57.29577951308232;			if(isNaN(ret)){				return 0;			} else {				return ret;			}		}		public static function angle2(v:Vec2D, v2:Vec2D):Number {			var sign = Vec2D.cross(v, v2)>0 ? 1 : -1;			return(sign*angle(v, v2));		}		public static function comp(v:Vec2D, v2:Vec2D):Number {			if (v.lengthSquared*v2.lengthSquared==0) {				return 0;			}			return Math.abs(v.x / v.length - v2.x / v2.length) + Math.abs(v.y / v.length - v2.y / v2.length);		}		public function get length():Number {			return Math.sqrt(x * x + y * y);		}		public function lerp(v2:Vec2D, t:Number):Vec2D {			return new Vec2D((1-t)*x + t*v2.x, (1-t)*y + t*v2.y);		}		public function get lengthSquared():Number {			return x * x + y * y;		}		public function set length(len:Number):void {			norm();			scale(len);		}		public function perpendicular(sign:Number = -1):Vec2D {			return new Vec2D(sign * y,- sign * x);		}		public function scale(val:Number):void {			x *= val;			y *= val;		}		public function scaled(val:Number):Vec2D {			return new Vec2D(x*val, y*val);		}		public function rotate(degrees:Number):void {			degrees *= 0.017453292519943295;			var s:Number = Math.sin(degrees);			var c:Number = Math.cos(degrees);			var tx:Number = x*c-y*s;			var ty:Number = x*s+y*c;			x = tx;			y = ty;		}		public function rotated(degrees:Number):Vec2D {			degrees *= 0.017453292519943295;			var s:Number = Math.sin(degrees);			var c:Number = Math.cos(degrees);			return new Vec2D(x * c - y * s,x * s + y * c);		}		public function reflect(normal:Vec2D):Vec2D {			var normal2:Vec2D = new Vec2D(normal.x, normal.y);			normal2.norm();			normal2.scale(2*dot(this, normal2));			return subtract(this,normal2);		}		public function constrain(amount:Number, type:String = "Greater") {			if (type == "Greater") {				if (length>amount) {					norm();					scale(amount);				}			}			if (type == "Always") {				norm();				scale(amount);			}			if (type == "Less") {				if (length<amount) {					norm();					scale(amount);				}			}		}		public function render(point:Vec2D, scale:Number, tgt:Sprite):void {			tgt.graphics.lineStyle(4, 0xFF0000, 100);			tgt.graphics.moveTo(point.x, point.y);			tgt.graphics.lineTo(point.x+x*scale, point.y+y*scale);			var nv:Vec2D = new Vec2D(-x, -y);			nv.norm();			nv.scale(7);			nv.rotate(-45);			tgt.graphics.lineTo(point.x+x*scale+nv.x, point.y+y*scale+nv.y);			tgt.graphics.moveTo(point.x+x*scale, point.y+y*scale);			nv.rotate(90);			tgt.graphics.lineTo(point.x+x*scale+nv.x, point.y+y*scale+nv.y);			tgt.graphics.lineStyle(2, 0x666666, 100);			tgt.graphics.moveTo(point.x, point.y);			tgt.graphics.lineTo(point.x+x*scale, point.y+y*scale);			var nv2:Vec2D = new Vec2D(-x, -y);			nv2.norm();			nv2.scale(7);			nv2.rotate(-45);			tgt.graphics.lineTo(point.x+x*scale+nv2.x, point.y+y*scale+nv2.y);			tgt.graphics.moveTo(point.x+x*scale, point.y+y*scale);			nv2.rotate(90);			tgt.graphics.lineTo(point.x+x*scale+nv2.x, point.y+y*scale+nv2.y);		}	}}