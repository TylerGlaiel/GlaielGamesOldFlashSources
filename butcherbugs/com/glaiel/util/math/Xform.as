//COPYRIGHT TYLER GLAIEL 2010//VERSION 1.0//LAST MODIFIED: 4/19/10package com.glaiel.util.math {  import flash.geom.Matrix  import flash.display.DisplayObject    public class Xform {	private var rot:Number;	private var pos:Vec2D;	private var scale:Vec2D;	    public function Xform(d:DisplayObject = null){		if(d == null){			rot = 0;			pos = new Vec2D(0, 0);			scale = new Vec2D(1, 1);		} else {			rot = d.rotation;			pos = new Vec2D(d.x, d.y);			scale = new Vec2D(d.scaleX, d.scaleY);		}    }		public function copy():Xform{		var temp:Xform = new Xform();		temp.rot = rot;		temp.pos = pos.copy();		temp.scale = scale.copy();		return temp;	}		public function get rotation():Number     {return rot;}	public function set rotation(r:Number)    {rot = r;}	public function get x():Number            {return pos.x;}	public function set x(px:Number)          {pos.x = px;}	public function get y():Number            {return pos.y;}	public function set y(py:Number)          {pos.y = py;}	public function get scaleX():Number       {return scale.x;}	public function set scaleX(sx:Number)     {scale.x = sx;}	public function get scaleY():Number       {return scale.y;}	public function set scaleY(sy:Number)     {scale.y = sy;}		public function get dir():Vec2D{		return Vec2D.fromAngle(rot);	}	public function set dir(v:Vec2D){		rot = v.rotation;	}		public function difference(xf2:Xform):Xform {		var diff:Xform = new Xform();		diff.pos.x = pos.x - xf2.pos.x;		diff.pos.y = pos.y - xf2.pos.y;		diff.scale.x = scale.x - xf2.scale.x;		diff.scale.y = scale.y - xf2.scale.y;		diff.rotation = -Vec2D.angle2(dir, xf2.dir);				return diff;	}		public function lerp(xf2:Xform, t:Number):Xform{		var lerped:Xform = new Xform();		lerped.pos = pos.lerp(xf2.pos, t);		lerped.scale = scale.lerp(xf2.scale, t);		lerped.rotation = rotation + t*Vec2D.angle2(dir, xf2.dir);				return lerped;	}		public function get inverse():Xform {		var inv:Xform = new Xform();		inv.pos.x = -pos.x;		inv.pos.y = -pos.y;		inv.scale.x = 1.0/scale.x;		inv.scale.y = 1.0/scale.y;		inv.dir = dir;//normalize rotation into 0, 360		inv.rot *= -1;				return inv;	}		public function get matrix():Matrix {		var mat:Matrix = new Matrix();     		mat.scale(scale.x, scale.y);		mat.rotate(rot * (Math.PI/180));		mat.translate(pos.x, pos.y);				return mat;	}		public function get revmatrix():Matrix {		var mat:Matrix = new Matrix();		mat.translate(pos.x, pos.y);		mat.rotate(rot * (Math.PI/180));		mat.scale(scale.x, scale.y);				return mat;	}		public function get invmatrix():Matrix {		return inverse.revmatrix;	}		public function apply(v:Vec2D):Vec2D {		var temp:Vec2D = v.copy();		temp.x *= scale.x;		temp.y *= scale.y;		temp.rotate(rot);		temp.x += pos.x;		temp.y += pos.y;				return temp;	}		public function revapply(v:Vec2D):Vec2D {		var temp:Vec2D = v.copy();				temp.x += pos.x;		temp.y += pos.y;				temp.rotate(rot);				temp.x *= scale.x;		temp.y *= scale.y;				return temp;	}		public function invapply(v:Vec2D):Vec2D {		return inverse.revapply(v);	}	  }}