package com.glaiel.util.math {		public class Collision {				private static const abs:Function = Math.abs; //optimization		private static const sqrt:Function = Math.sqrt; //optimization				public function Collision() { }				public static function CircleCircle(p1:Vec2D, p2:Vec2D, r1:Number, r2:Number):Boolean{			return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)<(r1+r2)*(r1+r2);		}		public static function CirclePoint(p1:Vec2D, p2:Vec2D, r:Number):Boolean{			return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)<(r)*(r);		}				public static function CircleLine(c_circle:Vec2D, r_circle:Number, o_line:Vec2D, v_line:Vec2D){			const vlx:Number = v_line.x;			const vly:Number = v_line.y;						const ccx:Number = c_circle.x;			const ccy:Number = c_circle.y;						const clx:Number = o_line.x;			const cly:Number = o_line.y;						const r:Number = r_circle;			const p:Number = ((ccx-clx)*vlx+(ccy-cly)*vly)/(vlx*vlx+vly*vly);						if(p < 0){				const dpx1:Number = clx-ccx;				const dpy1:Number = cly-ccy;				return dpx1*dpx1+dpy1*dpy1<r*r;			} else if (p > 1){				const dpx2:Number = clx+vlx-ccx;				const dpy2:Number = cly+vly-ccy;				return dpx2*dpx2+dpy2*dpy2<r*r;			} else {				const dpx3:Number = clx+vlx*p-ccx;				const dpy3:Number = cly+vly*p-ccy;				return dpx3*dpx3+dpy3*dpy3<r*r;			}					}					}	}